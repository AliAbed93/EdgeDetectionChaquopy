"""
SVG Export Module.

Converts processed contours into clean SVG paths suitable for:
- CNC machining
- Mold making
- CAD import

Output characteristics:
- Real-world units (millimeters)
- Smooth Bezier curves or polylines
- Configurable precision
- Optional metadata embedding
"""

import svgwrite
import numpy as np
from scipy import interpolate
from typing import Optional, Tuple, List
from pathlib import Path
from .config import ScannerConfig, ContourResult


class SVGExporter:
    """
    Exports lens contours to SVG format.
    """
    
    def __init__(self, config: ScannerConfig):
        self.config = config
    
    def export(
        self,
        contour_result: ContourResult,
        output_path: str,
        include_metadata: bool = True,
        include_dimensions: bool = False
    ) -> str:
        """
        Export contour to SVG file.
        
        Args:
            contour_result: Processed contour data
            output_path: Path for output SVG file
            include_metadata: Whether to include measurement metadata
            include_dimensions: Whether to add dimension annotations
            
        Returns:
            Path to created SVG file
        """
        points_mm = contour_result.contour_mm
        bbox = contour_result.bounding_box_mm
        
        # Add margin around contour
        margin = 5.0  # mm
        
        # SVG dimensions
        width = bbox[2] + 2 * margin
        height = bbox[3] + 2 * margin
        
        # Create SVG document with mm units
        dwg = svgwrite.Drawing(
            output_path,
            size=(f"{width}mm", f"{height}mm"),
            viewBox=f"0 0 {width} {height}"
        )
        
        # Add metadata as comments/description
        if include_metadata:
            self._add_metadata(dwg, contour_result)
        
        # Translate points to SVG coordinate system
        # (origin at top-left, with margin)
        translated_points = points_mm.copy()
        translated_points[:, 0] -= bbox[0] - margin
        translated_points[:, 1] -= bbox[1] - margin
        
        # Create path
        path_data = self._create_path_data(translated_points, contour_result.is_closed)
        
        # Add path to SVG
        path = dwg.path(
            d=path_data,
            stroke="black",
            stroke_width=f"{self.config.svg_stroke_width_mm}mm",
            fill="none"
        )
        dwg.add(path)
        
        # Add dimension annotations if requested
        if include_dimensions:
            self._add_dimensions(dwg, contour_result, margin, bbox)
        
        # Save SVG
        dwg.save()
        
        return output_path
    
    def _add_metadata(self, dwg: svgwrite.Drawing, result: ContourResult):
        """Add metadata to SVG document."""
        metadata = [
            f"Lens Contour - Generated by LensScanner",
            f"Perimeter: {result.perimeter_mm:.3f} mm",
            f"Area: {result.area_mm2:.3f} mmÂ²",
            f"Bounding Box: {result.bounding_box_mm[2]:.3f} x {result.bounding_box_mm[3]:.3f} mm",
            f"Centroid: ({result.centroid_mm[0]:.3f}, {result.centroid_mm[1]:.3f}) mm",
            f"Points: {len(result.contour_mm)}",
            f"Closed: {result.is_closed}"
        ]
        
        dwg.set_desc(title="Lens Contour", desc="\n".join(metadata))
    
    def _create_path_data(
        self,
        points: np.ndarray,
        is_closed: bool
    ) -> str:
        """
        Create SVG path data string.
        
        Uses cubic Bezier curves for smooth representation.
        """
        if len(points) < 2:
            return ""
        
        precision = self.config.svg_decimal_precision
        
        # Option 1: Polyline (simpler, more points)
        # return self._create_polyline_path(points, is_closed, precision)
        
        # Option 2: Bezier curves (smoother, fewer points)
        return self._create_bezier_path(points, is_closed, precision)
    
    def _create_polyline_path(
        self,
        points: np.ndarray,
        is_closed: bool,
        precision: int
    ) -> str:
        """Create path using line segments."""
        path_parts = []
        
        # Move to first point
        path_parts.append(f"M {points[0, 0]:.{precision}f} {points[0, 1]:.{precision}f}")
        
        # Line to subsequent points
        for point in points[1:]:
            path_parts.append(f"L {point[0]:.{precision}f} {point[1]:.{precision}f}")
        
        # Close path if needed
        if is_closed:
            path_parts.append("Z")
        
        return " ".join(path_parts)
    
    def _create_bezier_path(
        self,
        points: np.ndarray,
        is_closed: bool,
        precision: int
    ) -> str:
        """
        Create path using cubic Bezier curves.
        
        Fits smooth Bezier curves through the points for a cleaner
        representation with fewer path commands.
        """
        if len(points) < 4:
            return self._create_polyline_path(points, is_closed, precision)
        
        # Compute control points for cubic Bezier curves
        control_points = self._compute_bezier_control_points(points, is_closed)
        
        path_parts = []
        
        # Move to first point
        path_parts.append(f"M {points[0, 0]:.{precision}f} {points[0, 1]:.{precision}f}")
        
        # Add cubic Bezier curves
        n = len(points)
        for i in range(n - 1 if not is_closed else n):
            next_i = (i + 1) % n
            
            cp1 = control_points[i * 2]
            cp2 = control_points[i * 2 + 1]
            end = points[next_i]
            
            path_parts.append(
                f"C {cp1[0]:.{precision}f} {cp1[1]:.{precision}f} "
                f"{cp2[0]:.{precision}f} {cp2[1]:.{precision}f} "
                f"{end[0]:.{precision}f} {end[1]:.{precision}f}"
            )
        
        if is_closed:
            path_parts.append("Z")
        
        return " ".join(path_parts)
    
    def _compute_bezier_control_points(
        self,
        points: np.ndarray,
        is_closed: bool
    ) -> np.ndarray:
        """
        Compute control points for smooth cubic Bezier curves.
        
        Uses Catmull-Rom to Bezier conversion for smooth curves
        that pass through all points.
        """
        n = len(points)
        control_points = []
        
        for i in range(n):
            # Get neighboring points (with wrapping for closed curves)
            if is_closed:
                p0 = points[(i - 1) % n]
                p1 = points[i]
                p2 = points[(i + 1) % n]
                p3 = points[(i + 2) % n]
            else:
                p0 = points[max(0, i - 1)]
                p1 = points[i]
                p2 = points[min(n - 1, i + 1)]
                p3 = points[min(n - 1, i + 2)]
            
            # Catmull-Rom to Bezier conversion
            # Control point 1 (after p1)
            cp1 = p1 + (p2 - p0) / 6.0
            
            # Control point 2 (before p2)
            cp2 = p2 - (p3 - p1) / 6.0
            
            control_points.append(cp1)
            control_points.append(cp2)
        
        return np.array(control_points)
    
    def _add_dimensions(
        self,
        dwg: svgwrite.Drawing,
        result: ContourResult,
        margin: float,
        bbox: Tuple[float, float, float, float]
    ):
        """Add dimension annotations to SVG."""
        # Width dimension (below contour)
        width_y = bbox[3] + margin + 3
        dwg.add(dwg.line(
            start=(margin, width_y),
            end=(margin + bbox[2], width_y),
            stroke="blue",
            stroke_width="0.2mm"
        ))
        dwg.add(dwg.text(
            f"{bbox[2]:.2f} mm",
            insert=(margin + bbox[2] / 2, width_y + 2),
            text_anchor="middle",
            font_size="2mm",
            fill="blue"
        ))
        
        # Height dimension (right of contour)
        height_x = bbox[2] + margin + 3
        dwg.add(dwg.line(
            start=(height_x, margin),
            end=(height_x, margin + bbox[3]),
            stroke="blue",
            stroke_width="0.2mm"
        ))
        dwg.add(dwg.text(
            f"{bbox[3]:.2f} mm",
            insert=(height_x + 1, margin + bbox[3] / 2),
            writing_mode="tb",
            font_size="2mm",
            fill="blue"
        ))


class DXFExporter:
    """
    Alternative exporter for DXF format (CAD compatibility).
    
    Note: Requires ezdxf library. Not included in default dependencies.
    """
    
    def __init__(self, config: ScannerConfig):
        self.config = config
    
    def export(
        self,
        contour_result: ContourResult,
        output_path: str
    ) -> str:
        """
        Export contour to DXF file.
        
        Requires: pip install ezdxf
        """
        try:
            import ezdxf
        except ImportError:
            raise ImportError("DXF export requires ezdxf library: pip install ezdxf")
        
        # Create new DXF document
        doc = ezdxf.new('R2010')
        msp = doc.modelspace()
        
        points_mm = contour_result.contour_mm
        
        # Add polyline
        if contour_result.is_closed:
            # Closed polyline
            points_3d = [(p[0], p[1], 0) for p in points_mm]
            msp.add_lwpolyline(points_3d, close=True)
        else:
            # Open polyline
            points_3d = [(p[0], p[1], 0) for p in points_mm]
            msp.add_lwpolyline(points_3d, close=False)
        
        # Save DXF
        doc.saveas(output_path)
        
        return output_path
